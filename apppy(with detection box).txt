#TODO:
#1. how to connect with elderly
#3. show the result

import base64
import io
import os
import time
from datetime import datetime
from PIL import ImageDraw, ImageFont
from typing import Optional, List, Dict
import requests


from fastapi import FastAPI, UploadFile, File, WebSocket, WebSocketDisconnect, Depends
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from PIL import Image
from ultralytics import YOLO
from pymongo import MongoClient
from dotenv import load_dotenv
from fastapi.staticfiles import StaticFiles
from collections import Counter
from motor.motor_asyncio import AsyncIOMotorClient

load_dotenv()

MONGO_URI = os.getenv("MONGO_URI")
MONGO_DB = os.getenv("MONGO_DB")
CONF_THRESHOLD = float(os.getenv("CONF_THRESHOLD"))
IOU_THRESHOLD = float(os.getenv("IOU_THRESHOLD"))
SAVE_DEBUG_IMAGES = os.getenv("SAVE_DEBUG_IMAGES").lower() == "true"

client = AsyncIOMotorClient(MONGO_URI)
db = client[MONGO_DB]
detections_col = db["detections"]
collection = db["detections"]

# Load YOLOv11 weights
# If your model path differs, change here
MODEL_PATH = os.path.join("model", "best.pt")
model = YOLO(MODEL_PATH)

app = FastAPI(title="Fall Detection Platform", version="1.0")
app.mount("/storage", StaticFiles(directory="storage"), name="storage")

origins = [
    "http://localhost:5173",]
# CORS for local dev
app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["GET", "POST"],
    allow_headers=["*"],
)

class BBox(BaseModel):
    def to_dict(self):
        return {
            "x1": self.x1,
            "y1": self.y1,
            "x2": self.x2,
            "y2": self.y2,
            "conf": self.conf,
            "cls": self.cls
        }

class DetectResult(BaseModel):
    timestamp: str
    source: str
    status: str
    fall_count: int
    person_count: int
    total_frames: int
    falls: Optional[int] = 0
    boxes: Optional[List[Dict]] = None

def run_inference(pil_img: Image.Image):
    """Runs YOLO on a PIL image and returns boxes for class 'fall' (or your class name)."""
    results = model.predict(
        pil_img,
        conf=CONF_THRESHOLD,
        iou=IOU_THRESHOLD,
        verbose=False
    )
    r = results[0]
    boxes = []
    # Map class IDs to names
    names = r.names

    if r.boxes is not None and len(r.boxes) > 0:
        for b in r.boxes:
            cls_id = int(b.cls.item())
            cls_name = names.get(cls_id, str(cls_id))
            conf = float(b.conf.item())
            x1, y1, x2, y2 = [float(v) for v in b.xyxy[0].tolist()]

            
            if cls_name.lower() in ["fall", "person"]:
                boxes.append(
                    BBox(x1=x1, y1=y1, x2=x2, y2=y2, conf=conf, cls=cls_name)
                )

    return boxes

def save_detection(result: DetectResult):
    detections_col.insert_one(result.dict())

@app.get("/health")
def health():
    return {"ok": True, "model_loaded": os.path.exists(MODEL_PATH)}
@app.post("/infer")
async def infer_image(file: UploadFile = File(...)):
    """
    Single-image inference for uploaded images.
    Returns structured detections and stores them in MongoDB.
    """
    content = await file.read()
    pil_img = Image.open(io.BytesIO(content)).convert("RGB")

    boxes = run_inference(pil_img)
    print("Detected boxes:", boxes)
    falls = len(boxes)
    print("Received file:", file.filename)

    # Draw bounding boxes
    draw = ImageDraw.Draw(pil_img)
    for b in boxes:
        draw.rectangle(
            [(b.x1, b.y1), (b.x2, b.y2)],
            outline="red",
            width=3
        )
        # Optional: draw label
        draw.text((b.x1, b.y1 - 10), f"{b.cls} {b.conf:.2f}", fill="red")

    # Convert to base64
    buffered = io.BytesIO()
    pil_img.save(buffered, format="JPEG")
    img_str = base64.b64encode(buffered.getvalue()).decode("utf-8")

    doc = DetectResult(
        timestamp=datetime.utcnow().isoformat(),
        source="upload",
        falls=falls,
        boxes=boxes,
        image_url=img_str  # now contains base64 instead of path
    )
    save_detection(doc)
    print("docs", doc)
    return doc


NODE_API_URL = "http://localhost:5000/api/falls"

def send_to_node(elderly_id, status, frame_count, falls_in_frame):
    try:
        payload = {
            "elderlyId": elderly_id,
            "status": status,
            "frameCount": frame_count,
            "fallsInFrame": falls_in_frame,
        }
        res = requests.post(NODE_API_URL, json=payload)
        print("Sent to Node.js:", res.status_code, res.text)
    except Exception as e:
        print("Failed to send to Node.js:", e)

class WSMessage(BaseModel):
    frame_b64: str
    client_id: str

@app.websocket("/ws")
async def ws_detect(websocket: WebSocket):
    await websocket.accept()

    # Counters for 10s window
    start_time = time.time()
    status_counter = Counter()

    try:
        while True:
            msg = await websocket.receive_text()

            if msg.startswith("{"):
                import json
                data = json.loads(msg)
                elderly_id = data.get("elderlyId")  
                frame_b64 = data.get("frame_b64", "")
                client_id = data.get("client_id", "unknown")
            else:
                frame_b64 = msg
                client_id = "unknown"

            try:
                if frame_b64.startswith("data:image"):
                    frame_b64 = frame_b64.split(",", 1)[1]

                img_bytes = base64.b64decode(frame_b64)
                pil_img = Image.open(io.BytesIO(img_bytes)).convert("RGB")
            except Exception as e:
                print("Failed to decode image:", e)
                continue

            boxes = run_inference(pil_img)
            boxes_serializable = [b.to_dict() for b in boxes]
            falls = len([b for b in boxes if b.cls == "fall"])
            persons = len([b for b in boxes if b.cls == "person"])

            # Update counters
            if falls > 0:
                status_counter["fall"] += 1
            elif persons > 0:
                status_counter["person"] += 1
            else:
                status_counter["none"] += 1

            now = time.time()
            if now - start_time >= 10:
                # Decide status based on counts
                status = "none"
                if status_counter["fall"] >= 5:
                    status = "fall"
                elif status_counter["person"] >= 5:
                    status = "person"

                doc = DetectResult(
                    timestamp=datetime.utcnow().isoformat(),
                    source=f"webcam:{client_id}",
                    status=status,
                    fall_count=status_counter["fall"],
                    person_count=status_counter["person"],
                    total_frames=sum(status_counter.values())
                )
                await collection.insert_one(doc.dict())

                print("ðŸ”¹ Aggregated 10s result:", doc.dict())
                print(elderly_id, doc.status, doc.total_frames, doc.fall_count, doc.person_count)
                send_to_node(
                    elderly_id=elderly_id,
                    status=doc.status,
                    frame_count=doc.total_frames,
                    falls_in_frame=doc.fall_count,
                )

                await websocket.send_json({
                        "boxes": boxes_serializable,  
                        "status": status
                })
                start_time = now
                status_counter.clear()

    except WebSocketDisconnect:
        pass
    
@app.get("/detections")
def list_detections(limit: int = 50, source: Optional[str] = None):
    q = {}
    if source:
        q["source"] = source
    items = list(detections_col.find(q).sort([("_id", -1)]).limit(limit))
    # Convert ObjectId to str & pydantic-like
    for i in items:
        i["_id"] = str(i["_id"])
    return items
